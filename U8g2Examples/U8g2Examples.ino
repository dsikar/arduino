#include <Arduino.h>
#include <SPI.h>
#include <U8g2lib.h>
#include "Ug2Arrs.h"

// U8G2_SSD1306_128X64_NONAME_1_4W_SW_SPI u8g2(U8G2_R0, /* clock=*/ 13, /* data=*/ 11, /* cs=*/ 10, /* dc=*/ 9, /* reset=*/ 8);
U8G2_ST7920_128X64_F_SW_SPI u8g2(U8G2_R0, /* clock=*/ 15 /* A4 */ , /* data=*/ 17 /* A2 */, /* CS=*/ 16 /* A3 */, /* reset=*/ U8X8_PIN_NONE);

// <CODE GENERATED BY SCRIPT START>
// Nominal speeds array

//char *speeds[] = { " 0.50", " 0.51", " 0.52", " 0.53", " 0.54", " 0.55", " 0.56", " 0.57", " 0.58", " 0.59", " 0.60", " 0.61", " 0.62", " 0.63", " 0.64", " 0.65", " 0.66", " 0.67", " 0.68", " 0.69", 
//" 0.70", " 0.71", " 0.72", " 0.73", " 0.74", " 0.75", " 0.76", " 0.77", " 0.78", " 0.79", " 0.80", " 0.81", " 0.82", " 0.83", " 0.84", " 0.85", " 0.86", " 0.87", " 0.88", " 0.89", " 0.90", " 0.91", 
//" 0.92", " 0.93", " 0.94", " 0.95", " 0.96", " 0.97", " 0.98", " 0.99", " 1.00", " 1.10", " 1.20", " 1.30", " 1.40", " 1.50", " 1.60", " 1.70", " 1.80", " 1.90", " 2.00", " 2.10", " 2.20", " 2.30", 
//" 2.40", " 2.50", " 2.60", " 2.70", " 2.80", " 2.90", " 3.00", " 3.10", " 3.20", " 3.30", " 3.40", " 3.50", " 3.60", " 3.70", " 3.80", " 3.90", " 4.00", " 4.10", " 4.20", " 4.30", " 4.40", " 4.50", 
//" 4.60", " 4.70", " 4.80", " 4.90", " 5.00", " 6.00", " 7.00", " 8.00", " 9.00", "10.00", "11.00", "12.00", "13.00", "14.00", "15.00", "16.00", "16.00", "18.00", "20.00", "22.00", "24.00", "27.00", "30.00" };

//// Half frequencies array
//unsigned int halffreq[] = { 37500, 36764, 36057, 35377, 34722, 34090, 33482, 32894, 32327, 31779, 31249, 30737, 30241, 29761, 29296, 28846, 28409, 27985, 27573, 27173, 26785, 26408, 26041, 25684, 25337, 24999, 
//24671, 24350, 24038, 23734, 23437, 23148, 22865, 22590, 22321, 22058, 21802, 21551, 21306, 21067, 20833, 20604, 20380, 20161, 19946, 19736, 19531, 19329, 19132, 18939, 18750, 17045, 15624, 14423, 13392, 
//12499, 11718, 11029, 10416, 9868, 9374, 8928, 8522, 8152, 7812, 7499, 7211, 6944, 6696, 6465, 6249, 6048, 5859, 5681, 5514, 5357, 5208, 5067, 4934, 4807, 4687, 4573, 4464, 4360, 4261, 4166, 4076, 3989, 
//3906, 3826, 3750, 3125, 2678, 2343, 2083, 1875, 1704, 1562, 1442, 1339, 1250, 1171, 1171, 1041, 937, 852, 781, 694, 625 };

// menu tracker
int iMTracker = 0;

// OUR GENERIC STRUCT
struct MenuItem
{
  int iAbsMin; // always 0 except for menu tracker, starting at one to avoid printer tracker itself
  // Do not go above 14 NB this is in case there is a slight offset in read values, e.g. initial absolute value jumps from 0 to 2. TODO investigate jumps of 3.
  //int iAbsMax; //  = (iEncStep * arrMax) + (iEncStep / 2); calculate
  //int arrMin; // should alway be 0
  int arrMax; // used to calculate iAbsMax
  volatile int lastEncoded;
  volatile long encoderValue;
  long lastEncoderValue;
  int encoded; 
  byte xPos;
  byte yPos;        
};

// Two menu items, first has two options, second has 4 options
// (iEncStep * arrMax) + (iEncStep / 2);
MenuItem menuItem[4] = {{4,3,3,4,4,0,10,10}, // magic numbers, start at array position 1
                       {0,1,0,0,0,0,10,25}, // on off
                       {0,108,0,0,0,0,10,40}, // speeds                       
                       {0,301,0,0,0,0,10,55}}; // distance // add cycles later 
                                             // up down
                                             // manual/prog

// array boundaries
int arrMin = 0;
int arrMax = 108;

// <CODE GENERATED BY SCRIPT ENDS>

// encode step size
int iEncStep = 4;

// Encoder limits - outside these do not increment or decrement encoder value
int iAbsMin = 0;
// Do not go above 14 NB this is in case there is a slight offset in read values, e.g. initial absolute value jumps from 0 to 2. TODO investigate jumps of 3.
int iAbsMax = (iEncStep * arrMax) + (iEncStep / 2);

// ENCODER HANDLER
#define encoderPin1 2
#define encoderPin2 3
int encoderSwitchPin = 4; //push button switch

volatile int lastEncoded = 0;
volatile long encoderValue = 0;
long lastEncoderValue = 0;
int encoded = 0;
// long lastencoderValue = 0; 
// int lastMSB = 0;
// int lastLSB = 0;

// state machine
bool bOn = false;
bool bButtonReleased = true;
bool bButtonPushed = false;
// not really state machine, need to tidy up later
int iMenuIdx = 0;

/******************************

 Screw renderer

******************************/
void render(void) {
  // read state of digital pin
  char buf[15];
  
  u8g2.setFont(u8g2_font_ncenB08_tr);  
  // Get asterisk position, stored as encoder value in first MenuItem struct
  int iMit = GetMenuIndexTrack(); 
  int menuArraySize = sizeof(menuItem) / sizeof(menuItem[0]);
  for(int i = 0; i < menuArraySize; i++)
  {
    switch(i)
    {
      case 1: 
            sprintf(buf, "[%d]", (menuItem[i].encoderValue / iEncStep));   
            u8g2.drawStr( menuItem[i].xPos, menuItem[i].yPos, buf); 
            break;
      case 2:
            // strcpy_P(buffer, (char*)pgm_read_word(&(string_table[i])));
            strcpy_P(buf, (char*)pgm_read_word(&(speed_table[menuItem[i].encoderValue / iEncStep])));
            // this line is breaking our code 
            // sprintf(buf, "[%s]", speeds[(menuItem[i].encoderValue / iEncStep)]); 
            // speeds[(menuItem[i].encoderValue / iEncStep)]  
            u8g2.drawStr( menuItem[i].xPos, menuItem[i].yPos, buf); 
            break;  
      // distances
      case 3: 
            strcpy_P(buf, (char*)pgm_read_word(&(distance_table[menuItem[i].encoderValue / iEncStep])));
            // sprintf(buf, "[%d]", (menuItem[i].encoderValue / iEncStep));   
            u8g2.drawStr( menuItem[i].xPos, menuItem[i].yPos, buf);
            break;
      case 0:
        break;
    }
    // sprintf(buf, "[%d]", (menuItem[i].encoderValue / iEncStep));   
    // u8g2.drawStr( menuItem[i].xPos, menuItem[i].yPos, buf); 
    // if this is the current active item, print an asterisk to denote state 
    if(i == (menuItem[0].encoderValue / iEncStep))
    {
      // TODO make offsets variables      
      u8g2.drawStr( menuItem[i].xPos - 7, menuItem[i].yPos + 2, "*"); 
    }
  } 
  // debug encoded values
//  sprintf(buf, "1: [%d]", menuItem[0].lastEncoded);  
//  u8g2.drawStr(70, 10, buf);
//  sprintf(buf, "2: [%d]", menuItem[0].encoderValue);  
//  u8g2.drawStr(70, 20, buf);  
//  sprintf(buf, "2: [%d]", menuItem[0].lastEncoderValue);  
//  u8g2.drawStr(70, 30, buf);  
//  sprintf(buf, "2: [%d]", menuItem[0].encoded);  
//  u8g2.drawStr(70, 40, buf);  
//  if(digitalRead(encoderSwitchPin) == 0) // active low
//  {
//    sprintf(buf, "[%d]", (menuItem[0].encoderValue / iEncStep));   
//    u8g2.drawStr( 70, 20, buf);     
//  }
  // debug button press
//  sprintf(buf, "%d ",digitalRead(encoderSwitchPin));   
  //u8g2.drawStr( 70, 40, (bOn == true ? "On" : "Off")); 
//  // debug button press
//  sprintf(buf, "%d ",digitalRead(encoderSwitchPin));   
//  u8g2.drawStr( 100, 20, (bButtonPushed == true ? "P: 1" : "P: 0"));   
// // debug button press
//  sprintf(buf, "%d ",digitalRead(encoderSwitchPin));   
//  u8g2.drawStr( 100, 40, (bOn ? "On" : "Off")); 
//  // debug button press
//  sprintf(buf, "%d ",digitalRead(encoderSwitchPin));   
//  u8g2.drawStr( 100, 60, buf);  
}

void pushedButton(void)
{
  static int buttonPushCounter = 1;   // counter for the number of button presses
  static int buttonState = 1;         // current state of the button - active low
  static int lastButtonState = 1;     // previous state of the button - active low
  // read the pushbutton input pin:
  buttonState = digitalRead(encoderSwitchPin); 
  // compare the buttonState to its previous state
  if (buttonState != lastButtonState) 
  {
    // if the state has changed, increment the counter
    if (buttonState == LOW) {
      buttonPushCounter++;   
    }
    if (buttonPushCounter == 3)
    {
      // reset, maybe less computation than taking remainder of large integer
      buttonPushCounter = 1;
    }
    delay(50);
  }
  lastButtonState = buttonState;
  if (buttonPushCounter % 2 == 0) {
    bOn = true;
    SetMenuIndexTrack(bOn);
  } else {
    bOn = false;
    SetMenuIndexTrack(bOn);
  }  
}


// updateEncoder
/**************************************
 * Keep track of what index is being updated
 * Possible options
 * 1. Position of active control is being updated
 * update relevant index
 * 2. Control has been selected and is being updated
 * update relevantindex
 * TODO each control will have unique min and max pairs
 */

void SetMenuIndexTrack(bool bOn)
{
  if(bOn == true)
  { 
    // Change value of highlighted menu option
    iMenuIdx = menuItem[0].encoderValue / iEncStep;  
  } else
  {
    // change between menus
    iMenuIdx = 0; // menuItem[0].encoderValue / iEncStep;
  }
}

int GetMenuIndexTrack()
{
  return iMenuIdx; // menuItem[0].encoderValue / iEncStep;
}

void updateEncoder(){
  int MSB = digitalRead(encoderPin1); //MSB = most significant bit
  int LSB = digitalRead(encoderPin2); //LSB = least significant bit
  // check if rotary encoder has been pushed
  // pushedButton(); 
  // get array we are tracking
  int iMit = GetMenuIndexTrack();  
  int iAbsMax = (iEncStep * menuItem[iMit].arrMax) + (iEncStep / 2);
  encoded = (MSB << 1) |LSB; 
  //converting the 2 pin value to single number 
  int sum = (menuItem[iMit].lastEncoded << 2) | encoded;
  //adding it to the previous encoded value 
  if(sum == 0b1101 || sum == 0b0100 || sum == 0b0010 || sum == 0b1011){
    if(menuItem[iMit].encoderValue < iAbsMax) {
      menuItem[iMit].encoderValue++;
    }
  }
  if(sum == 0b1110 || sum == 0b0111 || sum == 0b0001 || sum == 0b1000){
    if(menuItem[iMit].encoderValue > menuItem[iMit].iAbsMin) {
      menuItem[iMit].encoderValue--;
    } 
  }
  // used for bitwise operations
  menuItem[iMit].lastEncoded = encoded;
  // update index
  if(menuItem[iMit].lastEncoderValue != menuItem[iMit].encoderValue) {
    menuItem[iMit].lastEncoderValue = menuItem[iMit].encoderValue;
  }  
}

void setup(void) {
  u8g2.begin();

  // Encoder pins
  pinMode(encoderPin1, INPUT);
  
  pinMode(encoderPin2, INPUT);
  pinMode(encoderSwitchPin,  INPUT);
 
  digitalWrite(encoderPin1, HIGH); //turn pullup resistor on
  digitalWrite(encoderPin2, HIGH); //turn pullup resistor on
  digitalWrite(encoderSwitchPin,  HIGH); //turn pullup resistor on
    
  // Encoder interrupts
  attachInterrupt(0, updateEncoder, CHANGE);
  attachInterrupt(1, updateEncoder, CHANGE);  
}

void loop(void) {
  u8g2.firstPage();
  do {
    pushedButton();
    render();   
  } while ( u8g2.nextPage() );
  // delay(50);
}
