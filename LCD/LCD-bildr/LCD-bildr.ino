#include <TimerOne.h>
//From bildr article: http://bildr.org/2012/08/rotary-encoder-arduino/
// modified to include interrupts
// if rotary value > 100, blink led, otherwise, no

// <CODE GENERATED BY SCRIPT START>
// Nominal speeds array

char *speeds[] = { " 0.50", " 0.51", " 0.52", " 0.53", " 0.54", " 0.55", " 0.56", " 0.57", " 0.58", " 0.59", " 0.60", " 0.61", " 0.62", " 0.63", " 0.64", " 0.65", " 0.66", " 0.67", " 0.68", " 0.69", 
" 0.70", " 0.71", " 0.72", " 0.73", " 0.74", " 0.75", " 0.76", " 0.77", " 0.78", " 0.79", " 0.80", " 0.81", " 0.82", " 0.83", " 0.84", " 0.85", " 0.86", " 0.87", " 0.88", " 0.89", " 0.90", " 0.91", 
" 0.92", " 0.93", " 0.94", " 0.95", " 0.96", " 0.97", " 0.98", " 0.99", " 1.00", " 1.10", " 1.20", " 1.30", " 1.40", " 1.50", " 1.60", " 1.70", " 1.80", " 1.90", " 2.00", " 2.10", " 2.20", " 2.30", 
" 2.40", " 2.50", " 2.60", " 2.70", " 2.80", " 2.90", " 3.00", " 3.10", " 3.20", " 3.30", " 3.40", " 3.50", " 3.60", " 3.70", " 3.80", " 3.90", " 4.00", " 4.10", " 4.20", " 4.30", " 4.40", " 4.50", 
" 4.60", " 4.70", " 4.80", " 4.90", " 5.00", " 6.00", " 7.00", " 8.00", " 9.00", "10.00", "11.00", "12.00", "13.00", "14.00", "15.00", "16.00", "16.00", "18.00", "20.00", "22.00", "24.00", "27.00", "30.00" };

// Half frequencies array
unsigned int halffreq[] = { 37500, 36764, 36057, 35377, 34722, 34090, 33482, 32894, 32327, 31779, 31249, 30737, 30241, 29761, 29296, 28846, 28409, 27985, 27573, 27173, 26785, 26408, 26041, 25684, 25337, 24999, 
24671, 24350, 24038, 23734, 23437, 23148, 22865, 22590, 22321, 22058, 21802, 21551, 21306, 21067, 20833, 20604, 20380, 20161, 19946, 19736, 19531, 19329, 19132, 18939, 18750, 17045, 15624, 14423, 13392, 
12499, 11718, 11029, 10416, 9868, 9374, 8928, 8522, 8152, 7812, 7499, 7211, 6944, 6696, 6465, 6249, 6048, 5859, 5681, 5514, 5357, 5208, 5067, 4934, 4807, 4687, 4573, 4464, 4360, 4261, 4166, 4076, 3989, 
3906, 3826, 3750, 3125, 2678, 2343, 2083, 1875, 1704, 1562, 1442, 1339, 1250, 1171, 1171, 1041, 937, 852, 781, 694, 625 };

// array boundaries
int arrMin = 0;
int arrMax = 108;

// <CODE GENERATED BY SCRIPT ENDS>

// encode step size
int iEncStep = 4;

// Encoder limits - outside these do not increment or decrement encoder value
int iAbsMin = 0;
// Do not go above 14 NB this is in case there is a slight offset in read values, e.g. initial absolute value jumps from 0 to 2. TODO investigate jumps of 3.
int iAbsMax = (iEncStep * arrMax) + (iEncStep / 2);

//these pins can not be changed 2/3 are special pins
int encoderPin1 = 2;
int encoderPin2 = 3;
int encoderSwitchPin = 4; //push button switch

volatile int lastEncoded = 0;
volatile long encoderValue = 0;

// state machine
bool bOn = false;
bool bButtonReleased = true;
bool bButtonPushed = false;

long lastEncoderValue = 0;
int encoded = 0;


void setup() {
  Serial.begin (9600);
  
  pinMode(encoderPin1, INPUT);
  pinMode(encoderPin2, INPUT);
  
  pinMode(encoderSwitchPin, INPUT);
  
  digitalWrite(encoderPin1, HIGH); //turn pullup resistor on
  digitalWrite(encoderPin2, HIGH); //turn pullup resistor on
  
  digitalWrite(encoderSwitchPin, HIGH); //turn pullup resistor on
  
  //call updateEncoder() when any high/low changed seen
  //on interrupt 0 (pin 2), or interrupt 1 (pin 3)
  attachInterrupt(0, updateEncoder, CHANGE);
  attachInterrupt(1, updateEncoder, CHANGE);

  // Initialize the digital pin as an output.
  // Pin 13 has an LED connected on most Arduino boards
  pinMode(13, OUTPUT);    
  
  // Timer1.initialize(100000); // set a timer of length 100000 microseconds (or 0.1 sec - or 10Hz => the led will blink 5 times, 5 cycles of on-and-off, per second)
  // testing 1cm/min
  Timer1.initialize(37500); // 37500 0,50 cm/min
  Timer1.attachInterrupt( timerIsr ); // attach the service routine here  

}

void loop(){
  //Do stuff here
  if(digitalRead(encoderSwitchPin)){
    // button is not being pushed
    bButtonReleased = true;
  }else{
    //button is being pushed
    bButtonPushed = true;
  }
  if(bButtonReleased == true && bButtonPushed == true) {
    // button has been pushed and released, changed on/off state
    bOn = !bOn;
    bButtonPushed = false;
  }
  


  // used to keep track of speed changes
  if(lastEncoderValue != encoderValue) {
    lastEncoderValue = encoderValue;
    Timer1.initialize(halffreq[encoderValue / iEncStep]);
    
    Serial.print(encoderValue / iEncStep);
    Serial.print(" (");  
    Serial.print(encoderValue);
    Serial.println(")");   
    Serial.print(speeds[encoderValue / iEncStep]);
    Serial.print(" cm/m - ");
    Serial.println(halffreq[encoderValue / iEncStep]); 
       
  }
  
  delay(200); //just here to slow down the output, and show it will work even during a delay
}

void updateEncoder(){
  int MSB = digitalRead(encoderPin1); //MSB = most significant bit
  int LSB = digitalRead(encoderPin2); //LSB = least significant bit
  
  encoded = (MSB << 1) |LSB; 
  //converting the 2 pin value to single number 
  int sum = (lastEncoded << 2) | encoded;
  //adding it to the previous encoded value 
  if(sum == 0b1101 || sum == 0b0100 || sum == 0b0010 || sum == 0b1011){
    if(encoderValue < iAbsMax) {
      encoderValue++;
    }
    // Serial.println("Increased encoderValue"); 
  }
  if(sum == 0b1110 || sum == 0b0111 || sum == 0b0001 || sum == 0b1000){
    if(encoderValue > iAbsMin) {
      encoderValue--;
    }
    // Serial.println("Decreased encoderValue"); 
  }
  // used for bitwise operations
  lastEncoded = encoded;
}

/// --------------------------
/// Custom ISR Timer Routine
/// --------------------------
void timerIsr()
{
    if(bOn == true) {
      // Toggle LED at ISR Timer interval
      digitalWrite( 13, digitalRead( 13 ) ^ 1 );      
    }
}
