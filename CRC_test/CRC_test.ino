/***
    Written by Christopher Andrews.
    CRC algorithm generated by pycrc, MIT licence ( https://github.com/tpircher/pycrc ).

    A CRC is a simple way of checking whether data has changed or become corrupted.
    This example calculates a CRC value directly on the EEPROM values.
    The purpose of this example is to highlight how the EEPROM object can be used just like an array.

    // NB Run on UNO
***/

#include <Arduino.h>
#include <EEPROM.h>

// 4. Absolute step count
unsigned int uiAbsoluteStepCount = 0;

void setup() {

  //Start serial
  Serial.begin(9600);
}

void CRC_info()
{
  //Print length of data to run CRC on.
  Serial.print("EEPROM length: ");
  Serial.println(EEPROM.length());

  //Print the result of calling eeprom_crc()
  Serial.print("CRC32 of EEPROM data: 0x");
  Serial.println(eeprom_crc(), HEX);
  Serial.print("\n\nDone!");  
}

 void saveConfigToEEPROM(int count)
 {
  // Note we are saving and retrieving the lastEncoderValue for every menu item
  // except index 0 (Menu Controller) and index 1 (start/stop) as we will always
  // power up in pause mode
  
  // what we need to save  Data type  Note
  // 1. Absolute position  unsigned long 
  // 2. Up down state      byte
  // 3. Prog/Man state     byte
  // 4. Number of cycles   byte
  // 5. Up speed           uint 16
  // 6. Down speed         uint 16
  // 7. Up pos             uint 16
  // 8. Down pos           uint 16
   struct LCDState {
    int menuUpDown_EncoderValue;
    int menuManProg_EncoderValue;                                                                                                           
    int menuCycles_EncoderValue;
    int menuUpSpeed_EncoderValue;                                                       
    int menuDownSpeed_EncoderValue;                                                    
    int menuEndPos_EncoderValue;
    int menuStartPos_EncoderValue;
    int AbsoluteStepCount;    
  };

  // Populate struct objects
  LCDState lcd_state;
  lcd_state.menuUpDown_EncoderValue = count;
  lcd_state.menuManProg_EncoderValue = count;
  lcd_state.menuCycles_EncoderValue = count;
  lcd_state.menuUpSpeed_EncoderValue = count;
  lcd_state.menuDownSpeed_EncoderValue = count;
  lcd_state.menuEndPos_EncoderValue = count;
  lcd_state.menuStartPos_EncoderValue = count;
  lcd_state.AbsoluteStepCount = count;

  // storage address
  int eeAddress = 0;
  // Store state - EEPROM library manages variable addresses
  EEPROM.put(eeAddress, lcd_state); 
}

/****************************
 * 
 * readConfigFromEEPROM
 * 
 * Read LCD State from EEPROM
 * 
 ****************************/
void readConfigFromEEPROM()
{
  struct LCDState {
    int menuUpDown_EncoderValue;
    int menuManProg_EncoderValue;                                                                                                           
    int menuCycles_EncoderValue;
    int menuUpSpeed_EncoderValue;                                                       
    int menuDownSpeed_EncoderValue;                                                    
    int menuEndPos_EncoderValue;
    int menuStartPos_EncoderValue;
    int AbsoluteStepCount;    
  };

  // LCD struct
  LCDState lcd_state;

  // storage address
  int eeAddress = 0;
  // get state - EEPROM library manages variable addresses
  EEPROM.get(eeAddress, lcd_state);  

  // retrieve absolute position and populate menu struct objects
  Serial.println("lcd_state.menuUpDown_EncoderValue");
  Serial.println(lcd_state.menuUpDown_EncoderValue);
  /*
  menuItem[MAN_PROG_INDEX].encoderValue = lcd_state.menuManProg_EncoderValue;
  menuItem[CYCLES_INDEX].encoderValue = lcd_state.menuCycles_EncoderValue;
  menuItem[UP_SPEED_INDEX].encoderValue = lcd_state.menuUpSpeed_EncoderValue;
  menuItem[DOWN_SPEED_INDEX].encoderValue = lcd_state.menuDownSpeed_EncoderValue;
  menuItem[END_POS_INDEX].encoderValue = lcd_state.menuEndPos_EncoderValue;
  menuItem[START_POS_INDEX].encoderValue = lcd_state.menuStartPos_EncoderValue; 
  */
  uiAbsoluteStepCount = lcd_state.AbsoluteStepCount; 
  // EEPROM library initialisation bug.
  // uiAbsoluteStepCount is 65535 when we expect 0
  Serial.println("uiAbsoluteStepCount");
  Serial.println(uiAbsoluteStepCount);
}

void loop() {
  static int iCount = 1;
  /* Empty loop */
  saveConfigToEEPROM(iCount);
  delay(2000);
  CRC_info();
  delay(2000);
  readConfigFromEEPROM();
  delay(2000);
}

unsigned long eeprom_crc(void) {

  const unsigned long crc_table[16] = {
    0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac,
    0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
    0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,
    0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c
  };

  unsigned long crc = ~0L;

  for (int index = 0 ; index < EEPROM.length()  ; ++index) {
    crc = crc_table[(crc ^ EEPROM[index]) & 0x0f] ^ (crc >> 4);
    crc = crc_table[(crc ^ (EEPROM[index] >> 4)) & 0x0f] ^ (crc >> 4);
    crc = ~crc;
  }
  return crc;
}
